import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import json
from pathlib import Path
import warnings
from typing import List, Dict, Tuple
import io

# IMPORT CONDICIONAL
try:
    from mplsoccer import Pitch
    import matplotlib.pyplot as plt
    MPLSOCCER_AVAILABLE = True
except ImportError:
    MPLSOCCER_AVAILABLE = False

warnings.filterwarnings('ignore')

# ============================================================================
# CONFIGURACI√ìN Y CACH√â OPTIMIZADO
# ============================================================================

@st.cache_data(ttl=3600, show_spinner=True, max_entries=2)
def cargar_archivo_subido(archivo_bytes, nombre_archivo: str, columnas_necesarias: List[str] = None):
    """
    Carga archivo parquet desde bytes subidos
    """
    try:
        if columnas_necesarias:
            df = pd.read_parquet(io.BytesIO(archivo_bytes), columns=columnas_necesarias)
        else:
            df = pd.read_parquet(io.BytesIO(archivo_bytes))
        
        # Optimizar tipos de datos
        for col in df.select_dtypes(include=['float64']).columns:
            df[col] = df[col].astype('float32')
        
        for col in df.select_dtypes(include=['int64']).columns:
            if df[col].max() < 32767 and df[col].min() > -32768:
                df[col] = df[col].astype('int16')
        
        return df
    except Exception as e:
        st.error(f"Error cargando datos: {str(e)}")
        return None

@st.cache_data(ttl=3600, show_spinner=False)
def obtener_lista_jugadores(df: pd.DataFrame) -> List[str]:
    """Obtiene lista √∫nica de jugadores de forma eficiente"""
    if 'playerName' not in df.columns:
        return []
    return sorted(df['playerName'].dropna().unique().tolist())

@st.cache_data(ttl=3600, show_spinner=False)
def obtener_lista_equipos(df: pd.DataFrame) -> List[str]:
    """Obtiene lista √∫nica de equipos"""
    if 'teamName' not in df.columns:
        return []
    return sorted(df['teamName'].dropna().unique().tolist())

@st.cache_data(ttl=3600, show_spinner=False)
def obtener_info_partidos(df: pd.DataFrame) -> Dict[str, dict]:
    """
    Obtiene informaci√≥n completa de partidos con nombres legibles
    """
    partidos = {}
    
    for match_id in df['match_id'].unique():
        match_data = df[df['match_id'] == match_id]
        
        # Obtener equipos del partido
        equipos = match_data['teamName'].unique()
        
        if len(equipos) >= 2:
            partido_nombre = f"{equipos[0]} vs {equipos[1]}"
        elif len(equipos) == 1:
            partido_nombre = f"{equipos[0]}"
        else:
            partido_nombre = f"Partido {match_id}"
        
        # Agregar fecha si est√° disponible
        if 'match_date' in match_data.columns:
            fecha = match_data['match_date'].iloc[0]
            if pd.notna(fecha) and fecha != 'Unknown':
                partido_nombre = f"{fecha} - {partido_nombre}"
        
        # Agregar stage si est√° disponible
        if 'stage_name' in match_data.columns:
            stage = match_data['stage_name'].iloc[0]
            if pd.notna(stage) and stage != 'Unknown':
                partido_nombre = f"{partido_nombre} ({stage})"
        
        partidos[partido_nombre] = {
            'match_id': match_id,
            'equipos': list(equipos),
            'fecha': match_data['match_date'].iloc[0] if 'match_date' in match_data.columns else 'Unknown',
            'stage': match_data['stage_name'].iloc[0] if 'stage_name' in match_data.columns else 'Unknown'
        }
    
    return partidos

# ============================================================================
# FUNCIONES DE VISUALIZACI√ìN
# ============================================================================

def visualizar_eventos_campo_optimizado(eventos_df: pd.DataFrame, titulo: str, 
                                        max_eventos: int = 300):
    """
    Visualiza eventos en el campo con l√≠mite para performance
    """
    if not MPLSOCCER_AVAILABLE:
        st.warning("‚ö†Ô∏è La visualizaci√≥n de campo requiere mplsoccer. Mostrando datos en tabla:")
        cols_mostrar = ['type', 'x', 'y', 'outcome']
        cols_disponibles = [col for col in cols_mostrar if col in eventos_df.columns]
        st.dataframe(eventos_df[cols_disponibles].head(50))
        return None
    
    from mplsoccer import Pitch
    import matplotlib.pyplot as plt
    
    # Limitar n√∫mero de eventos para performance
    if len(eventos_df) > max_eventos:
        st.warning(f"‚ö†Ô∏è Mostrando {max_eventos} de {len(eventos_df)} eventos para mejor rendimiento")
        eventos_df = eventos_df.sample(n=max_eventos, random_state=42)
    
    pitch = Pitch(pitch_type='opta', pitch_color='#22312b', line_color='#c7d5cc')
    fig, ax = pitch.draw(figsize=(10, 7))
    
    # Filtrar eventos v√°lidos
    eventos_validos = eventos_df[eventos_df['x'].notna() & eventos_df['y'].notna()].copy()
    
    if len(eventos_validos) == 0:
        ax.text(50, 50, 'No hay eventos con coordenadas', 
                ha='center', va='center', fontsize=14, color='white')
        plt.title(titulo, color='white', fontsize=14, pad=20)
        return fig
    
    # Colores por outcome
    color_map = {1: '#00ff85', 0: '#ff4444'}
    colors = [color_map.get(outcome, '#888888') for outcome in eventos_validos['outcome']]
    
    # Plotear eventos
    pitch.scatter(
        eventos_validos['x'], 
        eventos_validos['y'],
        s=80,
        c=colors,
        edgecolors='white',
        linewidth=0.5,
        alpha=0.7,
        ax=ax,
        zorder=2
    )
    
    plt.title(titulo, color='white', fontsize=12, pad=15)
    
    # Leyenda
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='#00ff85', label='√âxito'),
        Patch(facecolor='#ff4444', label='Fallo'),
    ]
    ax.legend(handles=legend_elements, loc='upper right', facecolor='#22312b', 
             edgecolor='white', labelcolor='white', fontsize=9)
    
    plt.tight_layout()
    return fig

# ============================================================================
# P√ÅGINA DE CARGA DE ARCHIVOS
# ============================================================================

def pagina_cargar_archivos():
    """P√°gina para subir archivos parquet"""
    st.title("üìÅ Cargar Archivos de Eventos")
    st.markdown("---")
    
    st.info("""
    ### üì§ Sube uno o m√°s archivos Parquet con datos de eventos
    
    **Formatos aceptados:**
    - `.parquet` - Archivo de eventos de OPTA procesados
    
    **Columnas esperadas:**
    - `playerName`, `teamName`, `match_id`
    - `type` o `type_name`, `x`, `y`, `outcome`
    - `competition`, `match_date`
    """)
    
    # Selector de archivos (permite m√∫ltiples)
    uploaded_files = st.file_uploader(
        "Selecciona archivo(s) Parquet:",
        type=['parquet'],
        accept_multiple_files=True,
        key='file_uploader',
        help="Puedes seleccionar uno o varios archivos .parquet"
    )
    
    if uploaded_files:
        st.success(f"‚úÖ {len(uploaded_files)} archivo(s) seleccionado(s)")
        
        # Mostrar informaci√≥n de cada archivo
        st.markdown("### üìä Archivos cargados:")
        
        for i, uploaded_file in enumerate(uploaded_files):
            with st.expander(f"üìÑ {uploaded_file.name} ({uploaded_file.size / (1024*1024):.2f} MB)", expanded=(i==0)):
                col1, col2 = st.columns([3, 1])
                
                with col1:
                    st.write(f"**Nombre:** {uploaded_file.name}")
                    st.write(f"**Tama√±o:** {uploaded_file.size / (1024*1024):.2f} MB")
                    st.write(f"**Tipo:** {uploaded_file.type}")
                
                with col2:
                    # Bot√≥n para cargar este archivo
                    if st.button(f"üîç Analizar", key=f"preview_btn_{i}", use_container_width=True):
                        # Guardar el archivo en session_state
                        file_bytes = uploaded_file.read()
                        uploaded_file.seek(0)  # Resetear el puntero
                        
                        st.session_state['archivo_actual'] = uploaded_file
                        st.session_state['archivo_actual_nombre'] = uploaded_file.name
                        st.session_state['archivo_actual_bytes'] = file_bytes
                        
                        # Vista previa r√°pida
                        with st.spinner("Cargando vista previa..."):
                            try:
                                df_preview = pd.read_parquet(io.BytesIO(file_bytes))
                                
                                st.markdown("#### Vista previa:")
                                col_a, col_b, col_c = st.columns(3)
                                
                                with col_a:
                                    st.metric("üìä Eventos", f"{len(df_preview):,}")
                                
                                with col_b:
                                    if 'playerName' in df_preview.columns:
                                        st.metric("üë§ Jugadores", f"{df_preview['playerName'].nunique():,}")
                                    elif 'player_name' in df_preview.columns:
                                        st.metric("üë§ Jugadores", f"{df_preview['player_name'].nunique():,}")
                                
                                with col_c:
                                    if 'match_id' in df_preview.columns:
                                        st.metric("üéÆ Partidos", f"{df_preview['match_id'].nunique():,}")
                                
                                # Mostrar informaci√≥n de partidos
                                if 'match_id' in df_preview.columns:
                                    st.markdown("#### üìã Partidos en este archivo:")
                                    
                                    partidos_info = obtener_info_partidos(df_preview)
                                    
                                    # Crear DataFrame para mostrar
                                    partidos_display = []
                                    for nombre_partido, info in list(partidos_info.items())[:10]:  # Mostrar primeros 10
                                        partidos_display.append({
                                            'Partido': nombre_partido,
                                            'Fecha': info['fecha'],
                                            'Stage': info['stage']
                                        })
                                    
                                    if partidos_display:
                                        df_partidos = pd.DataFrame(partidos_display)
                                        st.dataframe(df_partidos, use_container_width=True, hide_index=True)
                                        
                                        if len(partidos_info) > 10:
                                            st.caption(f"... y {len(partidos_info) - 10} partidos m√°s")
                                
                                # Mostrar primeras filas
                                st.markdown("#### üîç Primeras filas:")
                                st.dataframe(df_preview.head(10), use_container_width=True)
                                
                                # Bot√≥n para ir al an√°lisis
                                st.markdown("---")
                                if st.button("‚ñ∂Ô∏è Ir al An√°lisis", type="primary", key=f"analyze_btn_{i}", use_container_width=True):
                                    st.session_state['archivo_cargado'] = True
                                    st.rerun()
                                    
                            except Exception as e:
                                st.error(f"Error al cargar archivo: {str(e)}")
                                import traceback
                                st.code(traceback.format_exc())
        
        st.markdown("---")
        st.caption("üí° **Tip:** Selecciona un archivo y haz clic en 'Analizar' para ver una vista previa")
    
    else:
        st.warning("‚ö†Ô∏è No hay archivos seleccionados. Usa el bot√≥n de arriba para subir archivos.")

# ============================================================================
# P√ÅGINAS DE AN√ÅLISIS
# ============================================================================

def pagina_metricas_jugadores(df):
    """P√°gina de m√©tricas de jugadores"""
    st.title("üìà M√©tricas de Jugadores")
    st.markdown("---")
    
    # Bot√≥n para volver
    col1, col2 = st.columns([5, 1])
    with col2:
        if st.button("üìÅ Cambiar archivo", use_container_width=True):
            st.session_state['archivo_cargado'] = False
            st.rerun()
    
    st.success(f"‚úÖ Analizando: {st.session_state.get('archivo_actual_nombre', 'archivo')}")
    
    # Normalizar nombres de columnas
    col_player = 'playerName' if 'playerName' in df.columns else 'player_name'
    col_team = 'teamName' if 'teamName' in df.columns else 'team_name'
    col_type = 'type' if 'type' in df.columns else 'type_name'
    
    st.info(f"üìä {len(df):,} eventos | üë§ {df[col_player].nunique():,} jugadores")
    
    # Filtros en sidebar
    st.sidebar.header("üîç Filtros")
    
    # Filtro de competici√≥n
    if 'competition' in df.columns:
        competiciones = ['Todas'] + sorted(df['competition'].dropna().unique().tolist())
        competicion_sel = st.sidebar.selectbox(
            "Competici√≥n:",
            options=competiciones,
            index=0,
            key='comp_metricas'
        )
        
        if competicion_sel != 'Todas':
            df = df[df['competition'] == competicion_sel].copy()
    
    # Filtro de equipo
    equipos = ['Todos'] + obtener_lista_equipos(df)
    equipo_sel = st.sidebar.selectbox(
        "Equipo:",
        options=equipos,
        index=0,
        key='equipo_metricas'
    )
    
    if equipo_sel != 'Todos':
        df = df[df[col_team] == equipo_sel].copy()
    
    # Selector de jugador
    jugadores = obtener_lista_jugadores(df)
    
    if not jugadores:
        st.warning("‚ö†Ô∏è No hay jugadores disponibles con los filtros seleccionados")
        return
    
    jugador_sel = st.selectbox(
        "Selecciona un jugador:",
        options=jugadores,
        index=0,
        key='jugador_sel_metricas'
    )
    
    # Filtrar eventos del jugador
    df_jugador = df[df[col_player] == jugador_sel].copy()
    
    if len(df_jugador) == 0:
        st.warning(f"‚ö†Ô∏è No hay eventos para {jugador_sel}")
        return
    
    # Mostrar m√©tricas
    st.markdown("---")
    st.subheader(f"üìä Estad√≠sticas de {jugador_sel}")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if 'match_id' in df_jugador.columns:
            st.metric("Partidos", df_jugador['match_id'].nunique())
        else:
            st.metric("Partidos", "N/A")
    
    with col2:
        st.metric("Total Eventos", len(df_jugador))
    
    with col3:
        if 'outcome' in df_jugador.columns:
            eventos_con_outcome = df_jugador['outcome'].notna().sum()
            if eventos_con_outcome > 0:
                tasa_exito = (df_jugador['outcome'] == 1).sum() / eventos_con_outcome * 100
                st.metric("Tasa de √âxito", f"{tasa_exito:.1f}%")
            else:
                st.metric("Tasa de √âxito", "N/A")
        else:
            st.metric("Tasa de √âxito", "N/A")
    
    with col4:
        if 'match_id' in df_jugador.columns:
            eventos_por_partido = len(df_jugador) / df_jugador['match_id'].nunique()
            st.metric("Eventos/Partido", f"{eventos_por_partido:.1f}")
        else:
            st.metric("Eventos/Partido", "N/A")
    
    # Distribuci√≥n de eventos
    st.markdown("---")
    st.subheader("üìä Distribuci√≥n de Eventos")
    
    event_counts = df_jugador[col_type].value_counts()
    
    fig = go.Figure(data=[
        go.Bar(
            x=event_counts.values,
            y=event_counts.index,
            orientation='h',
            marker_color='steelblue'
        )
    ])
    
    fig.update_layout(
        title="Tipos de Eventos",
        xaxis_title="Cantidad",
        yaxis_title="Tipo de Evento",
        height=400,
        template='plotly_dark'
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Mapa de eventos
    if 'x' in df_jugador.columns and 'y' in df_jugador.columns:
        st.markdown("---")
        st.subheader("üó∫Ô∏è Mapa de Eventos")
        
        tipo_evento_filtro = st.selectbox(
            "Filtrar por tipo de evento:",
            options=['Todos'] + sorted(df_jugador[col_type].unique().tolist()),
            index=0,
            key='tipo_evento_mapa'
        )
        
        if tipo_evento_filtro != 'Todos':
            df_visualizar = df_jugador[df_jugador[col_type] == tipo_evento_filtro].copy()
        else:
            df_visualizar = df_jugador.copy()
        
        if len(df_visualizar) > 0:
            if MPLSOCCER_AVAILABLE:
                fig_campo = visualizar_eventos_campo_optimizado(
                    df_visualizar,
                    f"{jugador_sel} - {tipo_evento_filtro}"
                )
                if fig_campo:
                    st.pyplot(fig_campo)
                    plt.close()
            else:
                st.info("üìä Visualizaci√≥n de campo no disponible. Mostrando tabla:")
                cols_mostrar = [col_type, 'x', 'y']
                if 'outcome' in df_visualizar.columns:
                    cols_mostrar.append('outcome')
                st.dataframe(df_visualizar[cols_mostrar].head(100))
        else:
            st.info("No hay eventos para visualizar con el filtro seleccionado")


def pagina_analisis_eventos(df):
    """P√°gina de an√°lisis de eventos"""
    st.title("üéØ An√°lisis de Eventos")
    st.markdown("---")
    
    # Bot√≥n para volver
    col1, col2 = st.columns([5, 1])
    with col2:
        if st.button("üìÅ Cambiar archivo", use_container_width=True, key='cambiar_eventos'):
            st.session_state['archivo_cargado'] = False
            st.rerun()
    
    st.success(f"‚úÖ Analizando: {st.session_state.get('archivo_actual_nombre', 'archivo')}")
    st.info(f"üìä {len(df):,} eventos")
    
    # Verificar columnas necesarias
    if 'match_id' not in df.columns:
        st.error("‚ùå El archivo no contiene la columna 'match_id'")
        return
    
    # Normalizar nombres de columnas
    col_player = 'playerName' if 'playerName' in df.columns else 'player_name'
    col_team = 'teamName' if 'teamName' in df.columns else 'team_name'
    col_type = 'type' if 'type' in df.columns else 'type_name'
    
    # Selector de partido
    st.subheader("1Ô∏è‚É£ Seleccionar Partido")
    
    partidos_info = obtener_info_partidos(df)
    
    if not partidos_info:
        st.warning("‚ö†Ô∏è No hay partidos disponibles")
        return
    
    # Usar nombres legibles en el selector
    partido_sel = st.selectbox(
        "Selecciona un partido:",
        options=list(partidos_info.keys()),
        index=0,
        key='partido_analisis'
    )
    
    # Obtener el match_id del partido seleccionado
    match_id = partidos_info[partido_sel]['match_id']
    df_partido = df[df['match_id'] == match_id].copy()
    
    # Informaci√≥n del partido
    st.markdown("---")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("Total Eventos", len(df_partido))
    
    with col2:
        st.metric("Jugadores", df_partido[col_player].nunique())
    
    with col3:
        st.metric("Equipos", df_partido[col_team].nunique())
    
    # An√°lisis por equipo
    st.markdown("---")
    st.subheader("üìä An√°lisis por Equipo")
    
    equipos = df_partido[col_team].unique()
    
    if len(equipos) >= 2:
        col1, col2 = st.columns(2)
        
        for i, equipo in enumerate(equipos[:2]):
            df_equipo = df_partido[df_partido[col_team] == equipo]
            
            with col1 if i == 0 else col2:
                st.markdown(f"### {equipo}")
                
                event_counts = df_equipo[col_type].value_counts().head(10)
                
                fig = go.Figure(data=[
                    go.Bar(
                        x=event_counts.values,
                        y=event_counts.index,
                        orientation='h',
                        marker_color='coral' if i == 0 else 'steelblue'
                    )
                ])
                
                fig.update_layout(
                    title=f"Top 10 Eventos - {equipo}",
                    xaxis_title="Cantidad",
                    height=400,
                    template='plotly_dark'
                )
                
                st.plotly_chart(fig, use_container_width=True)


def pagina_expected_threat():
    """P√°gina placeholder para Expected Threat"""
    st.title("‚ö° Expected Threat (xT)")
    st.markdown("---")
    
    st.info("""
    üöß **Funcionalidad en desarrollo**
    
    Esta secci√≥n incluir√°:
    - C√°lculo de Expected Threat por zona
    - Mapas de calor de xT
    - An√°lisis de progresi√≥n de bal√≥n
    - Valoraci√≥n de pases y conducciones
    """)


# ============================================================================
# MAIN
# ============================================================================

def main():
    """Funci√≥n principal"""
    
    # Configuraci√≥n de la p√°gina
    st.set_page_config(
        page_title="WyScout Analytics",
        page_icon="‚öΩ",
        layout="wide",
        initial_sidebar_state="collapsed"
    )
    
    # CSS personalizado
    st.markdown("""
        <style>
        .main {
            background-color: #0e1117;
        }
        .stTabs [data-baseweb="tab-list"] {
            gap: 8px;
        }
        .stTabs [data-baseweb="tab"] {
            height: 50px;
            padding-left: 20px;
            padding-right: 20px;
            background-color: #1e2530;
            border-radius: 5px;
            color: white;
        }
        .stTabs [aria-selected="true"] {
            background-color: #2e3d50;
        }
        div[data-testid="stMetricValue"] {
            font-size: 24px;
        }
        </style>
    """, unsafe_allow_html=True)
    
    # Inicializar session state
    if 'archivo_cargado' not in st.session_state:
        st.session_state['archivo_cargado'] = False
    
    # Si NO hay archivo cargado, mostrar p√°gina de carga
    if not st.session_state['archivo_cargado']:
        pagina_cargar_archivos()
        return
    
    # Si HAY archivo cargado, cargar los datos y mostrar an√°lisis
    if 'archivo_actual_bytes' in st.session_state:
        
        # T√≠tulo principal
        st.title("‚öΩ WyScout Analytics Dashboard")
        st.caption(f"Analizando: {st.session_state.get('archivo_actual_nombre', 'archivo')}")
        st.markdown("---")
        
        # Cargar datos con cach√©
        with st.spinner("‚è≥ Cargando datos completos..."):
            df = cargar_archivo_subido(
                st.session_state['archivo_actual_bytes'],
                st.session_state['archivo_actual_nombre']
            )
        
        if df is None:
            st.error("‚ùå Error al cargar el archivo")
            if st.button("‚¨ÖÔ∏è Volver a selecci√≥n de archivos"):
                st.session_state['archivo_cargado'] = False
                st.rerun()
            return
        
        # Pesta√±as de an√°lisis
        tab1, tab2, tab3 = st.tabs([
            "üìà M√©tricas de Jugadores", 
            "üéØ An√°lisis de Eventos",
            "‚ö° Expected Threat (xT)"
        ])
        
        with tab1:
            try:
                pagina_metricas_jugadores(df)
            except Exception as e:
                st.error(f"‚ùå Error: {str(e)}")
                import traceback
                st.code(traceback.format_exc())
        
        with tab2:
            try:
                pagina_analisis_eventos(df)
            except Exception as e:
                st.error(f"‚ùå Error: {str(e)}")
                import traceback
                st.code(traceback.format_exc())
        
        with tab3:
            pagina_expected_threat()


if __name__ == "__main__":
    main()