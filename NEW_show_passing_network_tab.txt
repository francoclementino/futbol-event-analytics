def show_passing_network_tab():
    """Muestra la pesta√±a de an√°lisis de redes de pases con sistema de metadata"""
    
    st.markdown("### üï∏Ô∏è Passing Network Analysis")
    st.markdown("**Comparaci√≥n lado a lado de ambos equipos**")
    
    # Escanear carpetas
    data_scan = scan_data_directories()
    raw_dir = data_scan['raw_dir']
    
    # Modo de selecci√≥n
    st.markdown("---")
    col1, col2 = st.columns(2)
    
    with col1:
        data_mode = st.radio(
            "üìÇ Tipo de datos:",
            ["JSON Crudos", "Parquet Procesados"],
            help="Selecciona si quieres cargar archivos JSON crudos o datos ya procesados"
        )
    
    with col2:
        if data_mode == "JSON Crudos":
            # Contar JSONs en toda la estructura
            total_jsons = sum(1 for _ in raw_dir.rglob('*.json') if _.name != 'matches_metadata.json')
            st.info(f"üìä {total_jsons} archivos JSON disponibles")
        else:
            st.info(f"üì¶ {len(data_scan['parquet_files'])} archivos Parquet")
    
    # Selecci√≥n de archivo
    if data_mode == "Parquet Procesados":
        if not data_scan['parquet_files']:
            st.warning("‚ö†Ô∏è No hay archivos Parquet procesados. Usa 'JSON Crudos' primero.")
            return
        
        parquet_options = {}
        for pq in data_scan['parquet_files']:
            rel_path = pq.relative_to(data_scan['processed_dir'])
            parquet_options[str(rel_path)] = pq
        
        selected_name = st.selectbox(
            "Selecciona archivo Parquet:",
            list(parquet_options.keys())
        )
        
        if selected_name:
            selected_file = parquet_options[selected_name]
            
            with st.spinner('Cargando datos...'):
                df = load_parquet_data(selected_file)
            
            if df is not None:
                st.success(f"‚úÖ Cargados {len(df):,} eventos")
                st.info("üöß An√°lisis de Parquet en desarrollo. Por ahora, usa 'JSON Crudos' para redes de pases.")
    
    else:  # JSON Crudos
        st.markdown("---")
        st.markdown("#### üåé Selecci√≥n de Partidos")
        
        # Verificar si existe metadata global
        global_metadata_file = raw_dir / 'matches_metadata.json'
        
        if not global_metadata_file.exists():
            st.warning("‚ö†Ô∏è No se encontr√≥ metadata. Ejecuta primero: `python generate_metadata.py`")
            st.info("üí° O sube un archivo JSON manualmente:")
            
            # Fallback: File uploader
            uploaded_file = st.file_uploader(
                "Arrastra un archivo JSON del partido:",
                type=['json'],
                help="Sube un archivo JSON con datos OPTA / Stats Perform"
            )
            
            if uploaded_file is not None:
                with tempfile.NamedTemporaryFile(delete=False, suffix='.json', mode='w', encoding='utf-8') as tmp:
                    tmp.write(uploaded_file.getvalue().decode('utf-8'))
                    tmp_path = Path(tmp.name)
                
                st.info(f"üìÑ Archivo subido: {uploaded_file.name}")
                process_json_file(tmp_path)
            return
        
        # Cargar metadata global
        df_matches = load_matches_metadata(raw_dir, scope='global')
        
        if df_matches is None or len(df_matches) == 0:
            st.warning("‚ö†Ô∏è No hay partidos en la metadata. Agrega JSONs y ejecuta: `python generate_metadata.py`")
            return
        
        # SISTEMA DE FILTROS AVANZADOS
        st.markdown("##### üîç Filtros de B√∫squeda")
        
        # Nivel de selecci√≥n
        col1, col2, col3 = st.columns([2, 1, 1])
        
        with col1:
            selection_mode = st.radio(
                "Seleccionar por:",
                ["üåé Pa√≠s", "üåç Todos los pa√≠ses", "üèÜ Competici√≥n espec√≠fica"],
                horizontal=True
            )
        
        filtered_df = df_matches.copy()
        
        # Filtros seg√∫n modo de selecci√≥n
        if selection_mode == "üåé Pa√≠s":
            col1, col2, col3 = st.columns(3)
            
            with col1:
                countries = sorted(df_matches['country'].unique().tolist())
                selected_country = st.selectbox("Pa√≠s:", countries, key='country_filter')
                filtered_df = filtered_df[filtered_df['country'] == selected_country]
            
            with col2:
                competitions = ['Todas'] + sorted(filtered_df['competition'].unique().tolist())
                selected_comp = st.selectbox("Competici√≥n:", competitions, key='comp_filter')
                if selected_comp != 'Todas':
                    filtered_df = filtered_df[filtered_df['competition'] == selected_comp]
            
            with col3:
                seasons = ['Todas'] + sorted(filtered_df['season'].unique().tolist(), reverse=True)
                selected_season = st.selectbox("Temporada:", seasons, key='season_filter')
                if selected_season != 'Todas':
                    filtered_df = filtered_df[filtered_df['season'] == selected_season]
        
        elif selection_mode == "üèÜ Competici√≥n espec√≠fica":
            col1, col2 = st.columns(2)
            
            with col1:
                # Crear lista √∫nica de competiciones con pa√≠s
                comp_options = sorted(
                    df_matches[['country', 'competition', 'competition_full_name']]
                    .drop_duplicates()
                    .apply(lambda x: f"{x['country']} - {x['competition']}", axis=1)
                    .tolist()
                )
                selected_comp_full = st.selectbox("Competici√≥n:", comp_options, key='comp_full_filter')
                
                # Extraer pa√≠s y competici√≥n
                country_part, comp_part = selected_comp_full.split(' - ')
                filtered_df = filtered_df[
                    (filtered_df['country'] == country_part) & 
                    (filtered_df['competition'] == comp_part)
                ]
            
            with col2:
                seasons = ['Todas'] + sorted(filtered_df['season'].unique().tolist(), reverse=True)
                selected_season = st.selectbox("Temporada:", seasons, key='season_comp_filter')
                if selected_season != 'Todas':
                    filtered_df = filtered_df[filtered_df['season'] == selected_season]
        
        # B√∫squeda por equipo (com√∫n para todos los modos)
        col1, col2 = st.columns([3, 1])
        
        with col1:
            team_search = st.text_input(
                "üîç Buscar equipo:",
                placeholder="Escribe el nombre de un equipo...",
                help="Busca partidos que incluyan este equipo"
            )
            
            if team_search:
                filtered_df = filtered_df[
                    filtered_df['description'].str.contains(team_search, case=False, na=False)
                ]
        
        with col2:
            st.markdown("<br>", unsafe_allow_html=True)
            st.metric("Partidos", len(filtered_df))
        
        # Mostrar resultados
        if len(filtered_df) == 0:
            st.warning("‚ö†Ô∏è No se encontraron partidos con los filtros aplicados")
            return
        
        st.markdown("---")
        st.markdown(f"##### üìã {len(filtered_df)} Partidos Encontrados")
        
        # Crear opciones para selectbox con formato rico
        match_options = {}
        for idx, row in filtered_df.iterrows():
            # Formato: üìÖ DD/MM/YYYY | CODE | STAGE | Team1 vs Team2
            date_str = row['date'].strftime('%d/%m/%Y')
            code = row['competition_code'] if row['competition_code'] else row['competition'][:3].upper()
            stage = row['stage'] if row['stage'] else ''
            
            display_parts = [
                f"üìÖ {date_str}",
                f"{code}",
            ]
            
            if stage:
                display_parts.append(f"{stage}")
            
            display_parts.append(f"{row['description']}")
            
            display_name = " | ".join(display_parts)
            match_options[display_name] = row['filepath']
        
        # Selectbox con opciones formateadas
        selected_display = st.selectbox(
            "Selecciona el partido a analizar:",
            list(match_options.keys()),
            key='match_selector'
        )
        
        if selected_display:
            selected_filepath = match_options[selected_display]
            selected_file = raw_dir / selected_filepath
            
            # Mostrar info del partido seleccionado
            selected_match = filtered_df[filtered_df['filepath'] == selected_filepath].iloc[0]
            
            col1, col2, col3, col4, col5 = st.columns(5)
            with col1:
                st.info(f"üåé {selected_match['country']}")
            with col2:
                st.info(f"üìÖ {selected_match['date'].strftime('%d/%m/%Y')}")
            with col3:
                st.info(f"‚è∞ {selected_match['time']}")
            with col4:
                code = selected_match['competition_code'] if selected_match['competition_code'] else selected_match['competition'][:3]
                st.info(f"üèÜ {code}")
            with col5:
                st.info(f"üìä {selected_match['season']}")
            
            # Procesar el partido seleccionado
            if selected_file.exists():
                process_json_file(selected_file)
            else:
                st.error(f"‚ùå Archivo no encontrado: {selected_file}")
